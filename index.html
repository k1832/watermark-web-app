<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像透かし入れアプリ</title>
    <link rel="icon" href="favicon.ico" sizes="any">
    <!-- Optimize stylesheet loading -->
    <link rel="preload" href="style.css" as="style">
    <link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">
    <noscript>
        <link rel="stylesheet" href="style.css">
    </noscript>
    <!-- Optimize font loading -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
        media="print" onload="this.media='all'">
    <noscript>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    </noscript>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #2563eb;
            /* blue-600 */
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #2563eb;
            border-radius: 50%;
            cursor: pointer;
        }

        #previewCanvas {
            -webkit-touch-callout: none;
            user-select: none;
            touch-action: manipulation;
        }
    </style>

    <!-- Google tag (gtag.js) -->
    <script defer src="https://www.googletagmanager.com/gtag/js?id=G-8KYEBVC6J4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-8KYEBVC6J4', { 'anonymize_ip': true });
    </script>

</head>

<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="container mx-auto max-w-lg bg-white rounded-2xl shadow-2xl overflow-hidden flex flex-col my-4">

        <!-- Control Panel -->
        <div class="w-full bg-gray-50 p-6 space-y-6">
            <h1 class="text-2xl font-bold text-gray-800 text-center">透かし設定</h1>

            <!-- Preview -->
            <div class="w-full bg-gray-200 flex justify-center items-center p-4 min-h-[300px] rounded-lg">
                <canvas id="previewCanvas"
                    class="max-w-full max-h-[50vh] object-contain rounded-lg shadow-inner bg-gray-300"
                    style="display: none;"></canvas>
            </div>


            <div>
                <label for="imageLoader" class="block text-sm font-medium text-gray-700 mb-2">1. 画像を選択</label>
                <input type="file" id="imageLoader" accept="image/*" class="w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700
                    hover:file:bg-blue-100
                " />
            </div>

            <div>
                <label for="watermarkText" class="block text-sm font-medium text-gray-700 mb-2">2. 透かし文字</label>
                <input type="text" id="watermarkText" value="@k1832_"
                    class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>

            <div>
                <label for="watermarkColor" class="block text-sm font-medium text-gray-700 mb-2">3. 文字色</label>
                <div class="flex items-center space-x-2">
                    <input type="color" id="watermarkColor" value="#FFFFFF"
                        class="w-12 h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                    <input type="text" id="colorHexValue" value="#FFFFFF"
                        class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                </div>
            </div>

            <div>
                <label for="watermarkOpacity" class="block text-sm font-medium text-gray-700 mb-2">4. 不透明度</label>
                <div class="flex items-center space-x-3">
                    <input type="range" id="watermarkOpacity" min="0" max="1" step="0.01" value="0.5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="opacityValue" class="font-medium text-gray-700 text-sm w-12 text-right">50%</span>
                </div>
            </div>

            <div>
                <label for="fontSize" class="block text-sm font-medium text-gray-700 mb-2">5. 文字サイズ（出力時）</label>
                <div class="flex items-center space-x-3">
                    <input type="range" id="fontSize" min="8" max="256" step="1" value="64"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="fontSizeValue" class="font-medium text-gray-700 text-sm w-12 text-right">64px</span>
                </div>
            </div>

            <div>
                <label for="watermarkSpacing" class="block text-sm font-medium text-gray-700 mb-2">6. 間隔 (密度)</label>
                <div class="flex items-center space-x-3">
                    <input type="range" id="watermarkSpacing" min="1" max="10" step="0.5" value="4"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="spacingValue" class="font-medium text-gray-700 text-sm w-12 text-right">4.0</span>
                </div>
            </div>

            <div class="bg-green-50 border-l-4 border-green-500 text-green-700 p-4 rounded-lg flex items-start">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-green-500 mr-3 shrink-0" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round"
                        d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z">
                    </path>
                </svg>
                <div>
                    <p class="font-bold">処理はすべてデバイス上で完結</p>
                    <p class="text-sm">アップロードされた画像がサーバーに送信されることは一切ありません。すべての処理はあなたのブラウザ内で行われます。</p>
                </div>
            </div>

            <div>
                <button id="actionButton"
                    class="w-full bg-blue-600 text-white p-3 rounded-lg font-semibold hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                    画像をダウンロード
                </button>
            </div>

            <div id="iosSaveMessage"
                class="hidden bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-lg items-start">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-500 mr-3 shrink-0" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round"
                        d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <div>
                    <p class="text-sm font-bold">保存方法</p>
                    <p class="text-sm">ボタンを押すと新しいタブで画像が開きます。画像を長押しして「"写真"に保存」を選択してください。</p>
                </div>
            </div>

        </div>

        <div class="w-full bg-white p-4 border-t border-gray-100">
            <a href="https://x.com/k1832_" target="_blank" rel="noopener noreferrer"
                class="flex items-center justify-center text-gray-500 hover:text-gray-800 transition-colors"
                aria-label="Created by @k1832_ on X">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="w-4 h-4 mr-2"
                    viewBox="0 0 16 16">
                    <path
                        d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865l8.875 11.633Z">
                    </path>
                </svg>
                <span class="text-sm font-medium">Created by @k1832_</span>
            </a>
        </div>

    </div>

    <script>
        const imageLoader = document.getElementById('imageLoader');
        const watermarkText = document.getElementById('watermarkText');
        const watermarkColor = document.getElementById('watermarkColor');
        const colorHexValue = document.getElementById('colorHexValue');
        const watermarkOpacity = document.getElementById('watermarkOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const fontSize = document.getElementById('fontSize');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const watermarkSpacing = document.getElementById('watermarkSpacing');
        const spacingValue = document.getElementById('spacingValue');
        const actionButton = document.getElementById('actionButton');
        const iosSaveMessage = document.getElementById('iosSaveMessage');

        // 1. Preview Canvas (low-res, fast preview)
        const previewCanvas = document.getElementById('previewCanvas');
        const pCtx = previewCanvas.getContext('2d');

        // 2. Output Canvas (hidden, high-res export)
        const outputCanvas = document.createElement('canvas');
        const oCtx = outputCanvas.getContext('2d');

        // 3. Pattern Canvas (hidden, for optimization)
        const patternCanvas = document.createElement('canvas');
        const patternCtx = patternCanvas.getContext('2d');

        // Max preview resolution for performance
        const MAX_PREVIEW_DIMENSION = 1000;

        function trackEvent(eventName, eventParams = {}) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, eventParams);
            }
        }

        function checkIsIOS() {
            return /iPad|iPhone|iPod/.test(navigator.platform) ||
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 && !window.MSStream);
        }
        const isIOS = checkIsIOS();

        // State Management
        let originalImage = new Image();
        let previewScale = 1.0; // Preview scale vs original

        let currentWatermark = {
            text: '@k1832_',
            color: '#FFFFFF',
            opacity: 0.5,
            fontSize: 64,
            spacing: 4
        };

        let updatePending = false;
        let animationFrameId = null;

        /**
         * Request a redraw (optimized with requestAnimationFrame)
         */
        function requestRedraw() {
            if (!updatePending) {
                updatePending = true;
                animationFrameId = requestAnimationFrame(() => {
                    drawWatermark(previewCanvas, pCtx, previewScale);
                    updatePending = false;
                    animationFrameId = null;
                });
            }
        }

        function cancelPendingRedraw() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                updatePending = false;
                animationFrameId = null;
            }
        }

        // Initial Setup
        actionButton.disabled = true;
        fontSizeValue.textContent = `${currentWatermark.fontSize}px`;

        if (isIOS) {
            actionButton.textContent = '保存用に画像を開く';
            if (iosSaveMessage) {
                iosSaveMessage.classList.remove('hidden');
                iosSaveMessage.classList.add('flex');
            }
            trackEvent('ios_detected', {});
        }

        // --- Event Listeners ---

        imageLoader.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;

            cancelPendingRedraw();
            actionButton.disabled = true;

            const reader = new FileReader();
            reader.onload = event => {
                originalImage.onload = () => {
                    const width = originalImage.width;
                    const height = originalImage.height;

                    // 1. Setup output canvas (full-res)
                    outputCanvas.width = width;
                    outputCanvas.height = height;

                    // 2. Setup preview canvas (scaled down)
                    const maxDim = Math.max(width, height);
                    if (maxDim > MAX_PREVIEW_DIMENSION) {
                        previewScale = MAX_PREVIEW_DIMENSION / maxDim;
                    } else {
                        previewScale = 1.0;
                    }
                    previewCanvas.width = width * previewScale;
                    previewCanvas.height = height * previewScale;

                    requestRedraw();

                    previewCanvas.style.display = 'block';
                    actionButton.disabled = false; // Enable button
                    trackEvent('image_upload', { resolution: `${width}x${height}` });
                }
                originalImage.onerror = () => {
                    alert("画像の読み込みに失敗しました。");
                    actionButton.disabled = true;
                }
                originalImage.src = event.target.result;
            }
            reader.readAsDataURL(file);
        });

        watermarkText.addEventListener('input', e => {
            currentWatermark.text = e.target.value;
            requestRedraw();
        });

        watermarkColor.addEventListener('input', e => {
            currentWatermark.color = e.target.value;
            colorHexValue.value = e.target.value.toUpperCase(); // Update hex text input as well
            requestRedraw();
        });

        colorHexValue.addEventListener('input', e => {
            const value = e.target.value.toUpperCase();
            // Validate for 3 or 6 digit HEX code
            if (/^#([0-9A-F]{3}){1,2}$/i.test(value)) {
                currentWatermark.color = value;

                // Since input type="color" only accepts 6-digit HEX codes, normalize if 3 digits are provided
                let normalizedColor = value;
                if (value.length === 4) {
                    // #RGB -> #RRGGBB
                    normalizedColor = '#' + value[1] + value[1] + value[2] + value[2] + value[3] + value[3];
                }
                watermarkColor.value = normalizedColor.toLowerCase(); // Update color picker as well
                requestRedraw();
            }
        });

        watermarkOpacity.addEventListener('input', e => {
            currentWatermark.opacity = parseFloat(e.target.value);
            opacityValue.textContent = `${Math.round(currentWatermark.opacity * 100)}%`;
            requestRedraw();
        });

        fontSize.addEventListener('input', e => {
            currentWatermark.fontSize = parseInt(e.target.value, 10);
            fontSizeValue.textContent = `${currentWatermark.fontSize}px`;
            requestRedraw();
        });

        watermarkSpacing.addEventListener('input', e => {
            currentWatermark.spacing = parseFloat(e.target.value);
            spacingValue.textContent = currentWatermark.spacing.toFixed(1);
            requestRedraw();
        });

        actionButton.addEventListener('click', () => {
            // 1. Cancel pending preview
            cancelPendingRedraw();

            // 2. Draw on hi-res output canvas (Scale 1.0)
            drawWatermark(outputCanvas, oCtx, 1.0);

            trackEvent('image_action_click', { is_ios: isIOS });

            // 3. Generate image and save/display
            try {
                if (isIOS) {
                    // iOS: Use Data URL
                    const dataUrl = outputCanvas.toDataURL('image/png');

                    if (!dataUrl || dataUrl === 'data:,') {
                        alert('画像の生成に失敗しました。');
                        return;
                    }

                    // Open a blank window first
                    const newWindow = window.open('', '_blank');
                    if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                        alert('ポップアップがブロックされました。設定でこのサイトのポップアップを許可してください。');
                        return;
                    }

                    // Write HTML with the image into the new window
                    // This is more robust than opening the Data URL directly
                    newWindow.document.write('<!DOCTYPE html><head><title>画像プレビュー</title><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body style="margin:0; background:#222; display:flex; align-items:center; justify-content:center; min-height:100vh;">');
                    newWindow.document.write('<img src="' + dataUrl + '" style="max-width:100%; max-height:100vh; object-fit:contain;" alt="保存する画像">');
                    newWindow.document.write('</body></html>');
                    newWindow.document.close(); // Finish writing

                } else {
                    // Non-iOS: Use Blob for direct download
                    outputCanvas.toBlob(function (blob) {
                        if (!blob) {
                            alert('画像の生成に失敗しました。');
                            return;
                        }
                        const url = URL.createObjectURL(blob);

                        const link = document.createElement('a');
                        link.download = 'watermarked-image.png';
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);

                    }, 'image/png');
                }
            } catch (e) {
                console.error('Download/Save failed:', e);
                alert('画像の処理に失敗しました。');
            }
        });

        // --- Helper Functions ---

        function hexToRgba(hex, opacity) {
            let r = 0, g = 0, b = 0;
            if (typeof hex !== 'string' || !hex.startsWith('#')) return `rgba(255, 255, 255, ${opacity})`;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex[1] + hex[2], 16);
                g = parseInt(hex[3] + hex[4], 16);
                b = parseInt(hex[5] + hex[6], 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        /**
         * Main draw function (using pattern optimization)
         * @param {HTMLCanvasElement} canvas - Target canvas
         * @param {CanvasRenderingContext2D} ctx - Target context
         * @param {number} scale - Draw scale (1.0 = full res)
         */
        function drawWatermark(canvas, ctx, scale) {
            if (!originalImage.src || !originalImage.complete) {
                return;
            }

            // 1. Draw background image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            if (!currentWatermark.text) {
                return;
            }

            // --- Pattern Optimization ---

            // Adjust font size for scale
            const scaledFontSize = currentWatermark.fontSize * scale;
            const fontSetting = `bold ${scaledFontSize}px Inter`;

            patternCtx.font = fontSetting;

            // Measure text
            const textMetrics = patternCtx.measureText(currentWatermark.text);
            const textWidth = textMetrics.width;

            // Calculate pattern size/spacing
            const spacingFactor = currentWatermark.spacing;
            const stepX = textWidth + scaledFontSize * spacingFactor;
            const stepY = scaledFontSize * spacingFactor * 0.75;

            if (stepX <= 1 || stepY <= 1) return;

            // Set pattern canvas size
            patternCanvas.width = stepX;
            patternCanvas.height = stepY;

            // Reset pattern context settings after resize
            patternCtx.font = fontSetting;
            patternCtx.fillStyle = hexToRgba(currentWatermark.color, currentWatermark.opacity);
            patternCtx.textBaseline = 'middle';
            patternCtx.textAlign = 'left';

            // Draw text onto pattern canvas
            patternCtx.fillText(currentWatermark.text, 0, stepY / 2);

            // --- Draw Pattern to Main Canvas ---
            ctx.save();

            // Create pattern and set as fill style
            const pattern = ctx.createPattern(patternCanvas, 'repeat');
            ctx.fillStyle = pattern;

            // Rotate context
            const angleInDegrees = -30;
            ctx.rotate(angleInDegrees * Math.PI / 180);

            // Fill rotated area with pattern
            const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
            ctx.fillRect(-diagonal * 1.5, -diagonal * 1.5, diagonal * 3, diagonal * 3);

            ctx.restore();
        }

    </script>
</body>

</html>
